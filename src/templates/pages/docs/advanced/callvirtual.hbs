{{#markdown}}
**callVirtual**

![callVirtual]({{assets}}/img/documentation/webmiddle_callVirtual.png "callVirtual")

As previously said, a virtual has a type, attributes and children.

The **type** can be both a string or a function. If it is a
**function**, then we call such function “a service”. In terms of JSX, a
type is treated as a string when it begins with a lowercase letter,
example: `<article />`.

If the type is a **string**, then there isn’t much to evaluate,
everything is returned as is: the result will be the virtual itself, and
there will be no change to both options and webmiddle.

<br />
**1) Options calculation**

The options to use are calculated by **merging** the following options:

-   Current evaluate options.

-   Service options specified as static `options` property.

The merge is **in order**, meaning that the service options
override the current evaluate options.

Any of these options can be specified either directly as an object or as
a **function** returning an object. The options function is called with
the same **properties** that are passed to a normal service, namely:

-   Any virtual attributes.

-   The virtual children.

Moreover, we also pass the context calculated up to that point:

-   The webmiddle instance (as previously calculated).

-   The current evaluate options.

<br />
**4) Props validation via propTypes**

Services can specify the properties they are expecting by means of the
propTypes static property and the [PropTypes library](https://www.npmjs.com/package/proptypes).

<hr />
**Example:**

```javascript
const MyService = ({ url }) => {
  /* … */
}

MyService.propTypes = {
  url: PropTypes.string.isRequired,
};
```
<hr />

Such prop types validation is directly extracted from React, thus the
user can refer to [this article](https://facebook.github.io/react/docs/typechecking-with-proptypes.html) for details.

<br />
**5) Service execution **

Now that we have the service properties and the new context,
we are ready to call the service with them.

If the service fails, then `context.options.retries` is used to decide if
and how many retries should be attempted. A negative number means
infinite retries, while zero means no retries at all (the default).

The retries option can also be specified as a **function** that, given
the error object, returns the number of retries. Note that the function
can also return a promise which will be awaited.

Once all the retries have been attempted without success,
the `context.options.catch` is used.
Such option is a function that, given the error object, returns
(eventually with a promise) what should be used instead as the service
result.
{{/markdown}}