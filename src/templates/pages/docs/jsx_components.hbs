{{#markdown}}
### JSX components

```jsx
function ArticleDetails({ url }) {
  return (
    <Pipe>
      <HttpRequest
        name="rawHtml"
        contentType="text/html"
        url={url}
      />

      {({ rawHtml }) =>
        <HtmlToJson name="articleDetails" from={rawHtml}>
          { /* … */ }
        </HtmlToJson>
      }
    </Pipe>
  );
}
```

Components are the building blocks of the webmiddle framework, they can be
defined and composed to perform all the web data integration tasks.

The most general definition of a **component** is a function that given a
single object with the component parameters (also called **properties**)
does some (async) processing and eventually returns a resource.

A **resource** is an object

```javascript
{ name : String, contentType : String, content : Any }
```

Example: an html document could be represented as

```javascript
{
  name: "myHtmlDocument",
  contentType: "text/html",
  content: "[the actual html document as a string]"
}
```

The **contentType** allows the resource consumers to know the type of
the resource and thus to decide how to actually parse or read the
content, which might be a simple text string (e.g. in case of HTML) or a
pre-parsed object (e.g. in case of JSON).

Even though the function body of a component can be written completely in
plain JavaScript, most of the times the user will return **JSX** as in
the code above, since it grants modularity, extendibility and ease of
use.

Writing JSX is similar to writing an XML document, however, JavaScript
expressions can be embedded at any time in attributes and children by
enclosing them in {}.

The JSX is **transpiled** into a plain JavaScript object

```javascript
{ type : String | Function, attributes : Array, children : Array} 
```

representing a tree that the framework can easily navigate and evaluate.

This kind of object is called a virtual element, while the tree it
represents is called a virtual tree. From now on we will refer to such
type of object as a **virtual**.

Moreover, the XML-like elements can also refer to external functions.

In the code above all the elements with an uppercase letter are
actually external functions: [Pipe](https://github.com/webmiddle/webmiddle/tree/master/packages/webmiddle-component-pipe), [HttpRequest](https://github.com/webmiddle/webmiddle/tree/master/packages/webmiddle-component-http-request), [HtmlToJson](https://github.com/webmiddle/webmiddle/tree/master/packages/webmiddle-component-cheerio-to-json). They are
**core components** provided by the framework itself.

This way of working will be quite familiar to those that have used or
use ReactJS.

When the framework is parsing a component (transpiled) JSX and encounters
an element whose type is a function, like in the HttpRequest case, it
will actually call that function:

```jsx
<HttpRequest
  name="rawHtml"
  contentType="text/html"
  url={url}
/>
```

Roughly, the framework will execute

```javascript
HttpRequest({ name: “rawHtml”, contentType: “text/html”, url })
```

These may seem implementation details but are important for
understanding the workflow, how a component can be composed by means of
other components and how to develop them yourself.

If children are specified, then they will be passed as an array in the
“children” property.

**Example**:

```jsx
<Pipe>
  <HttpRequest
    name="rawHtml"
    contentType="text/html"
    url={url}
  />

  {({ rawHtml }) =>
    <HtmlToJson name="articleDetails" from={rawHtml}>
      ...
    </HtmlToJson>
  }
</Pipe>
```

Will be called as:

```javascript
Pipe({ 
  children: [{ type: HttpRequest, … }, { type: (rawHtml) => HtmlToJson, … }]
})
```

Note that there is no actual difference between a core component and a
component that you may want to develop yourself, as long as the same
function signature is followed.

This means that anyone can contribute by adding new components for doing
the more disparate things.
{{/markdown}}