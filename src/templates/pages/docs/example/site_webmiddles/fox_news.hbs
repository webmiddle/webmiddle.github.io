{{#markdown}}
### Fox News

<br />
#### ArticleDetails

```jsx
function ArticleDetails({ url }) {
  return (
    <Pipe>
      <HttpRequest
        name="rawHtml"
        contentType="text/html"
        url={url}
      />

      {({ rawHtml }) =>
        <HtmlToJson name="articleDetails" from={rawHtml}>
          <article el="article">
            <category
              el="h2 > a"
              condition={el =>
                el.attr('href').startsWith('/category/')
              }
            >
              {el =>
                // "/category/science/air-and-space/astronomy.html"
                // => "science/air-and-space/astronomy"
                el.attr('href').match(/category\/(.+).html/)[1]
              }
            </category>

            <title el="h1[itemprop='headline']">{elText()}</title>
            <date
              el="time[itemprop='datePublished']"
            >
              {elAttr('datetime')}
            </date>
            <text el="div[itemprop='articleBody'] p">
              {elPipe([
                elMap(elText()),
                elJoin('\n\n'),
              ])}
            </text>
          </article>
        </HtmlToJson>
      }
    </Pipe>
  );
}
```

Let’s dive deep into the ArticleDetails component and let’s understand
what it does and how.

We define a component that does an http request to fetch an html resource,
that we call “rawHtml”, this is done by means of the **HttpRequest**
component.

Then, we convert that “rawHtml” resource into an “articleDetails” JSON
resource with a given schema by means of the **HtmlToJson** component.

Whenever a child of the **Pipe** component is defined as a function
instead that directly as JSX (as in the image), that function will be
called by the Pipe component, by passing the “resources” object containing
all the resources that have been created until that point.

This is needed for retrieving those resources and using them in
subsequent components.

The Pipe component output is the resource returned by the last child, in
this case it will be the “articleDetails” resource returned by the
HtmlToJson component.

<br />
The schema of the “articleDetails” resource is defined via the
HtmlToJson children:

```jsx
{({ rawHtml }) =>
  <HtmlToJson name="articleDetails" from={rawHtml}>
    <article el="article">
      <category
        el="h2 > a"
        condition={el => el.attr('href').startsWith('/category/')}
      >
        {el =>
          // "/category/science/air-and-space/astronomy.html"
          // => "science/air-and-space/astronomy"
          el.attr('href').match(/category\/(.+).html/)[1]
        }
      </category>

      <title el="h1[itemprop='headline']">{elText()}</title>
      
      <date 
        el="time[itemprop='datePublished']"
      >
        {elAttr('datetime')}
      </date>

      <text el="div[itemprop='articleBody'] p">
        {elPipe([
          elMap(elText()),
          elJoin('\n\n'),
        ])}
      </text>
    </article>
  </HtmlToJson>
}
```

In our example the HtmlToJson component will generate an “articleDetails”
resource with contentType “application/json”.

The actual resource content will be something like

```javascript
{
  "root": {
    "article": {
      "category": "...",
      "title": "...",
      "date": "...",
      "text": "..."
    }
  }
}
```

Let’s look step-by-step at how the transformation is defined and
executed:

```jsx
<article el="article">
  ...
</article>
```

We are saying that we want an “article” property as the root of the JSON
object; the el=”article” attribute is telling the component to query the
HTML document with an “article” selector, so to get a list of HTML
elements (in this case all the elements with tagName equal to
“article”).

```jsx
<category
  el="h2 > a"
  condition={el => el.attr('href').startsWith('/category/')}
>
  {el =>
    // "/category/science/air-and-space/astronomy.html"
    // => "science/air-and-space/astronomy"
    el.attr('href').match(/category\/(.+).html/)[1]
  }
</category>
```

We are adding a “category” JSON property as child of the “article”
element.

Here, the “el” selector is relative to the parent HTML element, i.e. the
HTML element associated with the JSON “article” element.

In case multiple HTML elements are associated with the parent JSON
element (e.g. there are multiple elements with tagName “article” in our
example) then the first one is used.

Thus, writing el=”h2 &gt; a” is like saying to the component: associate
this JSON element with all the HTML elements matching the “h2 &gt; a”
selector, relative to the parent HTML element.

The condition attribute is telling the component: only keep those HTML
elements that pass this condition. The condition can be specified as a
function that takes each element and returns true if the element should
be included.

Note: the component is using **cheerio** for parsing the HTML document, it
is a NodeJS subset of jQuery, thus the selectors and the “el” objects
themselves follow the cheerio/jQuery syntax.

This means that when we talk about an “el” object, we are actually
referring to a collection of objects with a set of functions to
manipulate them, however most functions will actually be applied only on
the first element of the collection, like the “attr” function.

This does not matter in case of the “condition” function, since it is
called every time with a collection consisting of a single different
element, but will matter later.

Let’s now look at the “category” child, it is a JavaScript expression
instead that another JSX element; this is because we are actually
specifying what the value of the element should be.

Most of the times the data to extract from an HTML element will be
similar: its text content, the value of an attribute, etc. For this
reason, the component provides some helper functions that can make the
extraction more declarative.

```jsx
<title el="h1[itemprop='headline']">{elText()}</title>

<date 
  el="time[itemprop='datePublished']"
>
  {elAttr('datetime')}
</date>
```

A helper function takes zero or more arguments and returns a function
that, given a collection of elements (and the cheerio parser) returns a
certain value. By convention, their name always starts with “el”.

The following are the internal implementations of the **elText** and
**elAttr** helpers:

```jsx
function elText() {
  return el => el.val() || el.text();
}

function elAttr(attrName) {
  return el => el.attr(attrName);
}
```

Namely, elText() supports both form input elements and normal html
elements; in the former case it returns the value of the input, in the
latter case it returns the text of the html element.

The elAttr(attrName) attribute just returns the value of the attrName
attribute.

Both of these helpers operate on the first element of the collection,
however sometimes we want to extract the value by executing a function
on each element. This is what the **elMap** helper is for:

```jsx
function elMap(callback) {
  return (el, $) => el.map((i, currDomEl) => 
    callback($(currDomEl))
  );
}
```

It is just a plain implementation of the map function for Cheerio
collections: it calls the provided callback with each element and
creates an array with the result of each call.

Another helper called **elJoin** does what the name suggests: given a
separator, it joins the values in a cheerio collection with such
separator. This makes sense because data like strings can be contained
in a cheerio collection.

```jsx
function elJoin(separator) {
  return el => el.get().join(separator);
}
```

Finally, often we might want to specify a sequence of functions that we
want to execute to get the final value, where each function is called
with the output of the previous function.

This is what the **elPipe** helper is for:

```jsx
function elPipe(tasks) {
  return (el, $) =>
    tasks.reduce((currValue, task) => task(currValue, $), el);
}
```

Here is how these more advanced helpers are used in our example to
extract the text of the article, that in our HTML is contained in
paragraphs alternated with other types of content (images, ads, etc.)
that we don’t want to include:

```jsx
<text el="div[itemprop='articleBody'] p">
  {elPipe([
    elMap(elText()),
    elJoin('\n\n'),
  ])}
</text>
```

Basically, we are getting the text of each paragraph and then joining
them all together with two line breaks as separator.

<hr />
#### SearchArticles

```jsx
function SearchArticles({ query, startYear, endYear, pageNumber }) {
  return (
    <Pipe>
      <Browser
        name="rawHtml"
        contentType="text/html"
        url={
          `http://www.foxnews.com/search-results/search` +
          `?q=${encodeURIComponent(query)}&ss=fn` +
          (startYear ? `&min_date=${startYear}-01-01` : '') +
          (endYear ? `&max_date=${endYear}-12-31` : '') +
          `&start=${encodeURIComponent(toStart(pageNumber))}`
        }
        waitFor="[ng-repeat='article in articles']"
      />

      {({ rawHtml }) =>
        <HtmlToJson name="searchArticles" from={rawHtml}>
          <count el="[ng-bind='numFound']">
            {elPipe([
              elText(),
              normalizeCount(),
            ])}
          </count>
          <articles el="[ng-repeat='article in articles']">
            {elMap(el => (
              <article el={el}>
                <url
                  el="a[ng-bind='article.title']"
                >
                  {elAttr('href')}
                </url>
                
                <title el="a[ng-bind='article.title']">{elText()}</title>
                
                <description
                  el="[ng-if='article.description']"
                >
                  {elText()}
                </description>

                <date el=".search-date">{elText()}</date>
                
                <image
                  el="[ng-if='article.image'] img"
                >
                  {elAttr('src')}
                </image>
              </article>
            ))}
          </articles>
        </HtmlToJson>
      }
    </Pipe>
  );
}
```

Let’s see the differences with respect to the previous component.

Instead of the HttpRequest component, here we are using the **Browser**
component. It looks very similar in terms of interface, but it actually
uses a headless browser, such as PhtantomJS, to fetch the page and to
execute any JavaScript that may run on it.

This component is very useful in case of single page webapps, or with any
other kind of site that uses JavaScript to load and create parts of the
page dynamically.

This is the case of the search results of foxnews, which are loaded via
JavaScript.

The “waitFor” attribute tells the component to wait until an element with
the given selector is found on the page, it can be used to wait for the
JavaScript content to be fully loaded before returning the current
content of the page.

Differently from the previous component, where we only had an “url”
parameter, here we have other parameters such as “query” and
“pageNumber”, the url that is built is based on them.

You can note how the built-in “encodeURIComponent” JavaScript function
is used to properly include the parameters into the url, so to escape
any special url character.

Moreover, we are following a “pageNumber” approach, where the user can
specify which page of results to get. However, the actual site only
supports a “start” based approach, where the index of the first result
to return must be specified.

Still, we can just convert the pageNumber to the “start” value, by using
a simple function based on the number of results per page.

This is what the “toStart” function is for, it is a function created by
the component developer, it is not provided by the framework. It shows yet
another time how you can embed and reference functions and any other
kind of JavaScript expressions into JSX:

```jsx
function toStart(pageNumber) {
  return pageNumber * settings.resultsPerPage;
}
```

Here, the settings variable is just a simple configuration object that
can be used by any site component:

```jsx
export default {
  resultsPerPage: 10,
};
```

In terms of HtmlToJson conversion, an interesting operation is how the
list of HTML articles is converted into a JSON array via the elMap
helper.

In foxnews search results page, every article matches the
“\[ng-repeat=’article in articles’\]” selector, thus the “articles” JSON
element is associated with a collection containing all the HTML article
elements.

To specify the articles content, we map every HTML element of this
collection into a JSX element. This is what we do with

```jsx
{elMap(el => (
  <article el={el}>
    ...
  </article>
))}
```

Namely, instead of specifying the selector as a string in the “el”
attribute, we directly pass the element we have in scope. The component
will just use it. This is the power of JSX!

The elMap helper will return an array of JSX elements, and as stated
previously, when returning an array every item is evaluated recursively,
thus we will have a list of “article” elements in our JSON object.
{{/markdown}}