{{#markdown}}
### ProcessPage

It is the most complex among all the business logic services, its job is
to extract the list of articles for a given page number.

It is composed of the following steps:

-   **SearchArticles** to get the initial list of page articles, these
    articles contain incomplete information, such as missing the full
    text.<br />
    
    ```jsx
    <SearchArticles
      {...rest}
      name="articles"
      query={query}
      startYear={startYear}
      endYear={endYear}
      pageNumber={pageNumber}
    />
    ```

-   **Filter** to remove articles that don’t pass the project input, for
    example articles whose publication year is lower than the
    startYear.<br />
    The filtering step is needed because not every site might support
    the required level of granularity and customization in which results
    should be returned, thus this local filtering guarantees that
    unrelated articles won’t end up in the final list of articles.<br />
    
    ```jsx
    {({ articles }) =>
      <Filter
        name="filteredArticles"
        articles={articles}
        filters={filters}
      />
    } 
    ```

-   **For each article**

    -   **ArticleDetails** to get the missing information about the
        article.

    -   **Merge** to extend the article obtained from SearchArticles
        with the article obtained from ArticleDetails.
        <br />
        
        ```jsx
        {({ filteredArticles }) =>
          <ArrayMap
            name="mergedArticleResources"
            array={filteredArticles.content}
            limit={1}
            callback={articleContent => (
              <Pipe>
                <WithOptions catch={createEmptyArticleDetails}>
                  <ArticleDetails
                    {...rest}
                    name="articleDetails"
                    url={articleContent.url}
                  />
                </WithOptions>

                {() => ({
                  name: 'article',
                  contentType: 'application/json',
                  content: articleContent,
                })}

                {({ article, articleDetails }) =>
                  <Merge
                    name="mergedArticle"
                    sources={[article, articleDetails]}
                  />
                }
              </Pipe>
            )}
          />
        }
        ```

        Here, the “catch” webmiddle evaluation option is used to create
        an empty article in case the service irreparably fails.

-   A **final filtering** step that can now use all the new retrieved
    information to exclude any unrelated article.<br />

    ```jsx
    {/* Flatten the resource of resources */}
    {({ mergedArticleResources }) => ({
      name: 'mergedArticles',
      contentType: 'application/json',
      content: mergedArticleResources.content.map(r => r.content),
    })}

    {({ mergedArticles }) =>
      <Filter
        name="finalArticles"
        articles={mergedArticles}
        filters={filters}
      />
    }
    ```

Since each ArticleDetails call usually leads to network requests being
executed, the first filtering step is used to reduce right away the
number of articles, and thus to speed up the search.

{{/markdown}}